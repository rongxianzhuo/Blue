#pragma kernel Forward
#pragma kernel BackwardWeight
#pragma kernel BackwardBias
#pragma kernel BackwardInput

float eps;
uint layer_size;
uint layer_count;
StructuredBuffer<float> a;
StructuredBuffer<float> weight;
StructuredBuffer<float> bias;
StructuredBuffer<float> b_gradient;
RWStructuredBuffer<float> b;
RWStructuredBuffer<float> weight_gradient;
RWStructuredBuffer<float> bias_gradient;
RWStructuredBuffer<float> a_gradient;

[numthreads(512, 1, 1)]
void Forward(uint3 id : SV_DispatchThreadID)
{
    const uint start = id.x / layer_size * layer_size;
    float sum = 0.0;
    for (uint i = 0; i < layer_size; i++)
    {
        sum += a[start + i];
    }
    const float mean = sum / layer_size;
    sum = 0.0;
    for (uint j = 0; j < layer_size; j++)
    {
        const float f = a[start + j] - mean;
        sum += f * f;
    }
    const float var = sum / layer_size;
    const uint index_in_layer = id.x % layer_size;
    b[id.x] = (a[id.x] - mean) / sqrt(var + eps) * weight[index_in_layer] + bias[index_in_layer];
}

[numthreads(512, 1, 1)]
void BackwardWeight(uint3 id : SV_DispatchThreadID)
{
    float sum = 0.0;
    for (uint i = 0; i < layer_count; i++)
    {
        sum += b[id.x + i * layer_size] * b_gradient[id.x + i * layer_size];
    }
    weight_gradient[id.x] += sum;
}

[numthreads(512, 1, 1)]
void BackwardBias(uint3 id : SV_DispatchThreadID)
{
    float sum = 0.0;
    for (uint i = 0; i < layer_count; i++)
    {
        sum += b_gradient[id.x + i * layer_size];
    }
    bias_gradient[id.x] += sum;
}

[numthreads(512, 1, 1)]
void BackwardInput(uint3 id : SV_DispatchThreadID)
{
    const uint index_in_layer = id.x % layer_size;
    const uint start = id.x / layer_size * layer_size;
    float sum = 0.0;
    float sum1 = 0.0;
    for (uint i = 0; i < layer_size; i++)
    {
        sum += a[start + i];
        sum1 += b_gradient[start + i] * weight[index_in_layer];
    }
    const float mean = sum / layer_size;
    sum = 0.0;
    float sum2 = 0.0;
    for (uint j = 0; j < layer_size; j++)
    {
        const float f = a[start + j] - mean;
        sum += f * f;
        sum2 += b_gradient[start + j] * weight[index_in_layer] * (a[start + j] - mean);
    }
    const float var = sum / layer_size;
    const float g = b_gradient[id.x];
    a_gradient[id.x] += weight[index_in_layer] * g * pow(var + eps, -0.5) + (-1.0 / layer_size) * pow(var + eps, -0.5) * sum1
    - pow(var + eps, -1.5) * (a[id.x] - mean) / layer_size * sum2;
}